const chalk = require("chalk");
const axios = require("axios");
const ccxt = require("ccxt");
const _ = require("lodash");
const Taapi = require("./Taapi");
const ExchangeData = require("./ExchangeData");

class Client
{
    constructor(secret) {

        this.taapi = new Taapi(secret);

    }

    /**
     * Change endpoint to staging for instance
     * 
     * @param {} endpoint 
     */
    setTaapiApiEndpoint(endpoint) {
        this.taapi.setTaapiApiEndpoint(endpoint);
    }

    setDataProvider(name, secret, endpoint) {
        this.taapi.setDataProvider(name, secret, endpoint);
    }

    setDataProviderTaapiCache(secret, endpoint) {
        this.setDataProvider("taapicache", secret, endpoint);
    }

    setDataProviderAlphaVantage(secret) {
        this.setDataProvider("alphavantage", secret);
    }

    setDataProviderFinnHub(secret) {
        this.setDataProvider("finnhub", secret);
    }

    getExchangeStructure(exchangeId, print) {  
        return this.taapi.getExchangeStructure(exchangeId, prrint);
    }

    getExchangeTimeframes(exchangeId, print) {
        return this.taapi.getExchangeTimeframes(exchangeId, print);
    }

    /**
     * Fetch an indicator value.
     * 
     * @param {*} indicator 
     * @param {*} source 
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} params 
     * @param {*} backtrack 
     */
    async getIndicator(indicator, source, symbol, interval, params, backtrack, candlesCount) {

        let result = {};
        
        if(!candlesCount) {
            candlesCount = 100;
        }

        let taapiResult = await this.taapi.getIndicator(indicator, source, symbol, interval, params, backtrack, candlesCount);

        if(taapiResult && taapiResult.statusCode === 200) {
            result = taapiResult.data;
        } else {
            
            if(taapiResult.data) {
                if(taapiResult.data.errors && Array.isArray(taapiResult.data.errors)) {

                    throw new Error(JSON.stringify(taapiResult.data.errors));                 

                } else if(taapiResult.data.error && taapiResult.data.error.message) {

                    throw new Error(taapiResult.data.error.message);

                } else if(taapiResult.data.message) {

                    throw new Error(taapiResult.data.message);

                } else {

                    throw new Error("An unknow error has occurred!");

                }
            }
        }

        return result;
    }

    /**
     * Fetch an indicator value.
     * 
     * @param {*} indicator 
     * @param {*} source 
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} params 
     * @param {*} backtrack 
     */
    async getIndicatorGraphQL(indicator, source, symbol, interval, params, backtrack, candlesCount) {
        
        if(!candlesCount) {
            candlesCount = 100;
        }

        let result = await this.taapi.getIndicatorGraphQL(indicator, source, symbol, interval, params, backtrack, candlesCount);

        return result;
    }

    initBulkQueries() {
        this.taapi.initBulkQueries();
    }

    addBulkQuery(indicator, exchange, symbol, interval, params, backtrack, id, candlesCount) {
        this.taapi.addBulkQuery(indicator, exchange, symbol, interval, params, backtrack, id, candlesCount);
    }

    getBulkQueries() {
        return this.taapi.getBulkQueries();
    }

    async executeBulkQueries() {

        let response = await this.taapi.executeBulkQueries();
        
        // Loop through each indicator queries
        for(let responseDataKey in response) {

            // Fetch the result of current query
            const indicatorResult = response[responseDataKey].result;

            // Prepare a clean result response object
            let prettifiedResult = {};

            // There can be many results, each result are defined and an object containing a key / value pair
            for(let resultKey in indicatorResult) {

                prettifiedResult[indicatorResult[resultKey].key] = indicatorResult[resultKey].value;

            }

            // Replace the original result with this prettified one
            response[responseDataKey].result = prettifiedResult;
        }

        return response;
    }

    /** ************************************ RAW Queries ********************************* */

    /**
     * Init RAW bulk queries.
     */
    initRawBulkQueries() {
        this.taapi.initRawBulkQueries();
    }

    /**
     * Set the candles used by all indicators. 
     * Use this if you'll be calculating different 
     * indicators off of the same candle set.
     * 
     * @param {*} candles 
     */
    setRawCandles(candles) {
        this.taapi.setRawCandles(candles);
    }

    /**
     * Add a RAW bulk query. 
     * - Indicator is mandatory. 
     * - Candles are optional. Override the "RAW candles" if this query requires it's own set of candles.
     * - ID is optional. If none provided, the current timestamp (in milliseconds) is used as the ID.
     * 
     * @param {*} indicator 
     * @param {*} candles 
     * @param {*} id 
     */
    addRawBulkQuery(indicator, params, candles, id) {
        return this.taapi.addRawBulkQuery(indicator, params, candles, id);
    }

    /**
     * Executes the raw bulk queries added
     */
    async executeRawBulkQueries() {

        let response = await this.taapi.executeRawBulkQueries();
        
        // Loop through each indicator queries
        for(let responseDataKey in response) {

            // Fetch the result of current query
            const indicatorResult = response[responseDataKey].result;

            // Prepare a clean result response object
            let prettifiedResult = {};

            // There can be many results, each result are defined and an object containing a key / value pair
            for(let resultKey in indicatorResult) {

                prettifiedResult[indicatorResult[resultKey].key] = indicatorResult[resultKey].value;

            }

            // Replace the original result with this prettified one
            response[responseDataKey].result = prettifiedResult;
        }

        return response;
    }

    /* ******************************************** Utilities ******************************************** */

    setTelegramCredentials(botKey, chatId) {
        this.taapi.setTelegramCredentials(botKey, chatId);
    }

    async postTelegramMessage(message) {
        this.taapi.postTelegramMessage(message);
    }

    setSlackCredentials(webhookUrl, defaultChannel, icon, username) {
        this.taapi.setSlackCredentials(webhookUrl, defaultChannel, icon, username);
    }

    async postSlackhMessage(message, fields, channel) {
        this.taapi.postSlackhMessage(message, fields, channel);
    }
}

// Export the client
module.exports = Client;