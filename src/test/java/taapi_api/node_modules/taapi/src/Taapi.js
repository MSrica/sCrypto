const chalk = require("chalk");
const axios = require("axios");
const _ = require("lodash");
const ccxt = require("ccxt");
const ExchangeData = require("./ExchangeData");

class Taapi
{
    constructor(secret) {
        this.secret = secret;
        this.taapiApiEndpoint = "https://api.taapi.io";
        this.bulkQueries = [];
        this.rawBulkQueries = [];
        this.rawCandles = [];

        // Utilities
        this.dataProviderName = "CCXT";
        this.dataProviderSecret = "";
        this.dataProviderEndpoint = null;

        // Telegram
        this.telegramBotKey = null;
        this.telegramChatId = null;

        // Slack
        this.slackWebhookUrl = null;
        this.slackIcon = ":black_medium_square:";
        this.slackUsername = "TAAPI.IO";
        this.slackDefaultChannel = null;

        if(!secret) {
            console.log(chalk.red("You must provide your TAAPI.IO secret as the first constructor parameter!"));
        }
    }

    /* ***************************************** Utilities ************************************ */

    /**
     * Change endpoint to staging for instance
     * 
     * @param {} endpoint 
     */
    setTaapiApiEndpoint(endpoint) {
        this.taapiApiEndpoint = endpoint;
    }

    setDataProvider(name, secret, endpoint) {
        this.dataProviderName = name.toLowerCase();
        this.dataProviderSecret = secret;
        this.dataProviderEndpoint = endpoint;
    }

    setDataProviderTaapiCache(secret, endpoint) {
        this.setDataProvider("taapicache", secret, endpoint);
    }

    setDataProviderAlphaVantage(secret) {
        this.setDataProvider("alphavantage", secret);
    }

    setDataProviderFinnHub(secret) {
        this.setDataProvider("finnhub", secret);
    }

    getExchangeStructure(exchangeId, print) {        

        const exchangeClass = ccxt[exchangeId];        
        let exchange = new exchangeClass();

        if(print === true) {
            console.log(`${exchangeId} exchange structure:`);
            console.log(exchange);
        }

        return exchange;
    }

    getExchangeTimeframes(exchangeId, print) {

        let timeframes = this.getExchangeStructure(exchangeId).timeframes;

        if(print === true) {
            console.log(`${exchangeId} Timeframes:`);
            console.log(timeframes);
        }

        return timeframes;
    }

    /**
     * Fetch candles from an exchange. Check https://www.npmjs.com/package/ccxt for posible source's (in case of CCXT as data provider, source == exchangeId).
     * 
     * @param {*} source 
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} limit 
     * @param {*} backtrack 
     */
    async getCandles(source, symbol, interval, backtrack, candlesCount) {

        const exchangeData = new ExchangeData();

        exchangeData.setDataProvider(this.dataProviderName, this.dataProviderSecret, this.dataProviderEndpoint);

        return exchangeData.getCandles(source, symbol, interval, backtrack, candlesCount);
    }

    getGraphQLStringifiedParams(params) {

        let graphQLParams = [];

        for(let paramKey in params) {
            graphQLParams.push(`{name: "${paramKey}", value: "${params[paramKey]}"}`);
        }

        return `[${(graphQLParams).join(",")}]`;
    }

    getGraphQLStringifiedCandles(candles) {

        let graphQLCandles = [];

        for(let candleKey in candles) {
            const candle = candles[candleKey];

            graphQLCandles.push(`{timestamp: ${candle.timestamp / 1000}, open: ${candle.open}, high: ${candle.high}, low: ${candle.low}, close: ${candle.close}, volume: ${candle.volume}}`);
        }

        return `[${(graphQLCandles).join(",")}]`;
    }

    /* ***************************************** Single call with REST ************************************ */

    /**
     * Fetch an indicator value.
     * 
     * @param {*} indicator 
     * @param {*} source 
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} params 
     * @param {*} backtrack 
     */
    async getIndicator(indicator, source, symbol, interval, params, backtrack, candlesCount) {

        // Fetch the actual candles from the exchange
        let candles = await this.getCandles(source, symbol, interval, backtrack, candlesCount);

        // Init extra params if not already done
        if(!params) { params = {}; }

        // Add the secret and candles to the call
        params.secret = this.secret;
        params.candles = candles;

        // Init result
        let result = {};

        // Call TAAPI.IO for the indicator value
        await axios.post(`${this.taapiApiEndpoint}/${indicator}`, {
            params
        }).then(function (response) {

            // Success
            result.statusCode = 200;
            result.data = response.data;
        }).catch(function (error) {
            
            // Something went wrong
            if(error.response) {

                if(error.response.status) {
                    result.statusCode = error.response.status;
                } else {
                    result.statusCode = 500;
                }

                if(error.response.data) {
                    result.data = error.response.data;
                } else {
                    result.data = { error: { message: "Unknown exchange or server error. If you're running a local server, make sure that's actually running!" }};
                }
                
            } else {
                result.statusCode = 500;
                result.data = { error: { message: "Unknown exchange or server error. If you're running a local server, make sure that's actually running!" }};
            }
            
            
        });

        // Return the indicator result
        return result;
    }

    /* ***************************************** Single call with GraphQL ************************************ */

    /**
     * Fetch an indicator value with GraphQL.
     * 
     * @param {*} indicator 
     * @param {*} source 
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} params 
     * @param {*} backtrack 
     */
    async getIndicatorGraphQL(indicator, source, symbol, interval, params, backtrack, candlesCount) {

        // Fetch the actual candles from the exchange
        let candles = await this.getCandles(source, symbol, interval, backtrack, candlesCount);

        // Init extra params if not already done
        if(!params) { params = {}; }

        // Init result
        let executionResponse = {
            statusCode: 200,
            data: {}
        };

        let query = `
            query {                
                indicator(
                    secret: "${this.secret}",
                    indicator: "${indicator}",
                    params: ${this.getGraphQLStringifiedParams(params)},
                    candles: ${this.getGraphQLStringifiedCandles(candles)},
                ) {
                    indicator,
                    result {
                        key,
                        value
                    }
                }
            }
        `;

        executionResponse = await this.taapiGraphQLQuery(query);

        // Return the indicator result
        return executionResponse.data.indicator;
    }


    /* ***************************************** Bulk Queries ************************************ */

    /**
     * The below methods allow for querying in "bulk". These methods take 
     * the parameters: source, symbol, interval etc... and will then 
     * first fetch the needed candles from the exchanges (data provider) 
     * and pass them on to the API for indicator calculation.
     */

    /**
     * Init bulk queries. This resets and re-inits all bulk queries.
     */
    initBulkQueries() {
        this.bulkQueries = [];
    }

    /**
     * Add a bulk query. Make sure to run 'initBulkQueries()' after every bulk execution.
     * 
     * - Indicator is mandatory.
     * - Exchange is mandatory.
     * - Symbol is mandatory.
     * - Interval is mandatory.
     * - Backtrack is optional. Default is 0
     * - ID is optional. If none set, an ID is auto-generated based off of the indicator, exchange, symbol, interval and backtrack.
     * 
     * @param {*} indicator 
     * @param {*} exchange 
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} backtrack 
     * @param {*} id 
     * @param {*} candlesCount 
     */
    addBulkQuery(indicator, exchange, symbol, interval, params, backtrack, id, candlesCount) {

        /* 
        Plans are enforced from the API side. 
        Do not limit the client as to how many 
        calls can be added here! 
        */

        // Validate mandatory parameters
        if(indicator && exchange && symbol && interval) {

            // Init extra params if not already done
            if(!params) { params = {}; }

            // Default the backtrack
            if(!backtrack) { backtrack = 0; }

            // Default an ID
            if(!id) { id = `${indicator}_${exchange}_${symbol}_${interval}`; }

            // Candles count
            if(!candlesCount) { candlesCount = 100; }

            this.bulkQueries.push({
                id: id,
                indicator: indicator,
                exchange: exchange,
                symbol: symbol,
                interval: interval,
                params: params,
                backtrack: backtrack,
                candlesCount: candlesCount,
            });

        } else {
            console.log("indicator, exchange, symbol, interval as all mandatory parameters!");
        }
    }

    /**
     * Returns all currently added bulk queries.
     */
    getBulkQueries() {
        return this.bulkQueries;
    }

    /**
     * Returns the individual GraphQL queries
     */
    async getBulkStringifiedQueries() {

        let self = this;

        let promises = [];
        let caches = {};

        for(let queryIndex in this.bulkQueries) {

            // Prepare query
            const query = this.bulkQueries[queryIndex];   

            // Create a cache ID
            let cacheId = `${query.exchange}_${query.symbol}_${query.interval}_${query.backtrack}_${query.candlesCount}`;

            if(!caches[cacheId]) {

                caches[cacheId] = 1;

                promises.push(new Promise(async function(resolve, reject) {                             

                    // Get a fresh set of candles from the exchange
                    let candles = await self.getCandles(query.exchange, query.symbol, query.interval, query.backtrack, query.candlesCount);

                    resolve({
                        cacheId: cacheId,
                        candles: candles
                    });

                }));
            } else {
                caches[cacheId]++;
            }
        }

        // Find the default candles
        var defaultCandlesKey = _.max(Object.keys(caches), function (o) { return caches[o]; });

        // Listen for all primises resolved and prepare the GraphQL queries
        let bulkStringifiedQueries = await Promise.all(promises).then(function(values) {

            let candles = {};

            for(let k in values) {

                const value = values[k];

                candles[value.cacheId] = value.candles;
            }

            let defaultCandles = candles[defaultCandlesKey];
            delete candles[defaultCandlesKey];

            let stringifiedQueries = [];

            for(let queryIndex in self.bulkQueries) {

                const query = self.bulkQueries[queryIndex];

                let cacheId = `${query.exchange}_${query.symbol}_${query.interval}_${query.backtrack}_${query.candlesCount}`;

                if(query.id) {
                    stringifiedQueries.push(`{indicator: "${query.indicator}", params: ${self.getGraphQLStringifiedParams(query.params)}, candles: ${self.getGraphQLStringifiedCandles(candles[cacheId])}, id: "${query.id}"}`);
                } else {
                    stringifiedQueries.push(`{indicator: "${query.indicator}", params: ${self.getGraphQLStringifiedParams(query.params)}, candles: ${self.getGraphQLStringifiedCandles(candles[cacheId])}`);
                }

            }

            return {
                defaultCandles: self.getGraphQLStringifiedCandles(defaultCandles),
                queries: `[${stringifiedQueries.join(",")}]`
            };
        });

        return bulkStringifiedQueries;
    }

    /**
     * Execute bulk queries.
     */
    async executeBulkQueries() {

        let executionResponse = {
            statusCode: 200,
            data: {}
        };

        let bulkStringifiedQueries = await this.getBulkStringifiedQueries();

        let query = `
            query {
                indicators(
                    secret: "${this.secret}",
                    candles: ${bulkStringifiedQueries.defaultCandles},
                    queries: ${bulkStringifiedQueries.queries}
                ) {
                    id,
                    indicator,
                    result {
                        key,
                        value
                    }
                }
            }
        `;

        executionResponse = await this.taapiGraphQLQuery(query);

        return executionResponse.data.indicators;
    }

    /* *************************************** Raw Bulk Queries *********************************** */

    /**
     * The below methods allow for querying in "raw bulk". These methods take 
     * the parameters: indicator and candles only and passes them on directly 
     * to the API for indicator calculation.
     */

    /**
     * Init RAW bulk queries.
     */
    initRawBulkQueries() {
        this.rawBulkQueries = [];
        this.rawCandles = [];
    }

    /**
     * Set the candles used by all indicators. Use this if you'll be calculating different indicators off of the same candle set.
     * 
     * @param {*} candles 
     */
    setRawCandles(candles) {

        if(candles && Array.isArray(candles)) {

            this.rawCandles = candles;

        } else {
            console.log("Candles is a mandatory parameter, and must be an array with correct formatting according to the documentation!");
        }
    }

    /**
     * Get's the RAW candles added.
     */
    getRawCandles() {
        return this.rawCandles;
    }

    /**
     * Add a RAW bulk query. 
     * - Indicator is mandatory. 
     * - Candles are optional. Override the "RAW candles" if this query requires it's own set of candles.
     * - ID is optional. If none provided, the current timestamp (in milliseconds) is used as the ID.
     * 
     * @param {*} indicator 
     * @param {*} candles 
     * @param {*} id 
     */
    addRawBulkQuery(indicator, params, candles, id) {

        if(indicator) {

            // Init extra params if not already done
            if(!params) { params = {}; }

            // Default candles to empty array
            if(!candles) { candles = []; }

            if(!id) {
                id = (new Date()).getTime();
            }

            this.rawBulkQueries.push({
                id: id,
                indicator: indicator,
                params: params,
                candles: candles,
            });

        } else {
            console.log("indicator, exchange, symbol, interval as all mandatory parameters!");
        }
    }

    getRawBulkQueries() {
        return this.rawBulkQueries;
    }

    getRawBulkStringifiedQueries() {

        let stringifiedQueries = [];

        for(let queryIndex in this.rawBulkQueries) {

            // Prepare query
            const query = this.rawBulkQueries[queryIndex];

            if(query.id) {
                stringifiedQueries.push(`{indicator: "${query.indicator}", params: ${this.getGraphQLStringifiedParams(query.params)}, candles: ${this.getGraphQLStringifiedCandles(query.candles)}, id: "${query.id}"}`);
            } else {
                stringifiedQueries.push(`{indicator: "${query.indicator}", params: ${this.getGraphQLStringifiedParams(query.params)}, candles: ${this.getGraphQLStringifiedCandles(query.candles)}`);
            }
        }

        return `[${stringifiedQueries.join(",")}]`;
    }

    async executeRawBulkQueries() {

        let executionResponse = {
            statusCode: 200,
            data: {}
        };

        let query = `
            query {
                indicators(
                    secret: "${this.secret}",
                    queries: ${this.getRawBulkStringifiedQueries()},
                    candles: ${this.getGraphQLStringifiedCandles(this.getRawCandles())},
                ) {
                    id,
                    indicator,
                    result {
                        key,
                        value
                    }
                }
            }
        `;

        executionResponse = await this.taapiGraphQLQuery(query);

        return executionResponse.data.indicators;
    }

    async taapiGraphQLQuery(query) {

        let config = {
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            }
        }

        let executionResponse = {
            statusCode: 200,
            data: {}
        };

        await axios.post(`${this.taapiApiEndpoint}/graphql`, JSON.stringify({query}), config)
            .then(function (response) {

                // Prettify result

                // Get the real response data. GraphQL adds and extra 'data' object wrapper
                executionResponse = response.data;

            }).catch(function (error) {
                
                // Something went wrong
                if(error.response) {
                    
                    if(error.response.status) {
                        executionResponse.statusCode = error.response.status;
                    } else {
                        executionResponse.statusCode = 500;
                    }
    
                    if(error.response.data) {
                        executionResponse.data = error.response.data;
                    } else {
                        executionResponse.data = { error: { message: "Unknown exchange or server error. If you're running a local server, make sure that's actually running!" }};
                    }
                    
                } else {
                    executionResponse.statusCode = 500;
                    executionResponse.data = { error: { message: "Unknown exchange or server error. If you're running a local server, make sure that's actually running!" }};
                }                
                
            });

        return executionResponse;
    }

    /* ******************************************** Utilities ******************************************** */

    setTelegramCredentials(botKey, chatId) {
        this.telegramBotKey = botKey;
        this.telegramChatId = chatId;
    }

    async postTelegramMessage(message) {

        if(this.telegramBotKey && this.telegramChatId) {
        axios.get(`https://api.telegram.org/bot${this.telegramBotKey}/sendMessage`, {
            params: {
                    chat_id: this.telegramChatId,
                    text: message,
                }
            })
            .then(function (response) { })
            .catch(function (error) { console.log(error); });
        } else {
            console.error("Telegram bot-key / chat-id not set!");
        }
    }

    setSlackCredentials(webhookUrl, defaultChannel, icon, username) {
        this.slackWebhookUrl = webhookUrl;
        this.slackDefaultChannel = defaultChannel;

        if(icon) { this.slackIcon = icon; }        
        if(username) { this.slackUsername = username; }
    }

    async postSlackhMessage(message, fields, channel) {

        var slack = require('slack-notify')(this.slackWebhookUrl);        

        if(!fields) { fields = {}; }

        if(channel || this.slackDefaultChannel) {
            let slackMessage = slack.extend({
                channel: channel || this.slackDefaultChannel,
                icon_emoji: this.slackIcon,
                username: this.slackUsername
            });
            
            slackMessage({
                text: message,
                fields: fields
            });
        }
    }
}

// Export TAAPI
module.exports = Taapi;